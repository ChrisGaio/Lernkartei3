<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Karteikarten – Lernapp (Auto‑Fragen v2)</title>
  <meta name="description" content="Interaktive Lernkarten mit automatischer Fragen/Antworten-Erzeugung aus langen PDF/TXT-Texten (offline, regelbasiert).">
  <style>
    :root{
      --bg1:#0f0c29; --bg2:#302b63; --bg3:#24243e;
      --accent:#7c4dff; --accent2:#00c2ff;
      --text:#e8eaf6; --muted:#b0b7c3;
      --ok:#2ecc71; --again:#ff6b6b; --warn:#ffb703;
      --cardEdge:#2a2d4a; --shadow: 0 12px 30px rgba(0,0,0,.35);
    }
    *{box-sizing:border-box} html,body{height:100%}
    body{margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial;color:var(--text);
      background: radial-gradient(1200px 800px at 20% -10%, var(--bg2), transparent 60%),
                  radial-gradient(1000px 800px at 110% 10%, var(--bg3), transparent 60%),
                  linear-gradient(160deg,var(--bg1),var(--bg3));}
    header{display:flex;gap:12px;align-items:center;padding:14px 18px;position:sticky;top:0;z-index:7;
      background:linear-gradient(160deg,rgba(15,12,41,.85),rgba(36,36,62,.85));backdrop-filter:blur(8px);
      border-bottom:1px solid rgba(255,255,255,.08)}
    header h1{font-size:18px;margin:0;font-weight:650;letter-spacing:.3px}
    header .spacer{flex:1}
    header .badge{font-size:12px;padding:6px 10px;border-radius:999px;background:linear-gradient(90deg,var(--accent),var(--accent2));box-shadow:var(--shadow)}
    main{padding:16px;display:grid;gap:14px;max-width:1100px;margin:0 auto}
    .toolbar{display:flex;gap:8px;flex-wrap:wrap;align-items:center;background:rgba(255,255,255,.04);padding:10px;
      border:1px solid rgba(255,255,255,.06);border-radius:12px}
    select,button,input[type="file"]::file-selector-button{background:rgba(255,255,255,.08);color:var(--text);border:1px solid rgba(255,255,255,.10);
      border-radius:10px;padding:10px 12px;font-size:14px}
    button{cursor:pointer} button.primary{background:linear-gradient(120deg,var(--accent),var(--accent2));border:none;color:white;font-weight:600}
    .board{display:grid;grid-template-columns:1fr;gap:14px}
    @media(min-width:900px){.board{grid-template-columns:1.15fr .85fr}}
    .cardwrap{perspective:1200px;min-height:360px}
    .card{width:100%;min-height:360px;border-radius:16px;background:linear-gradient(180deg,rgba(255,255,255,.03),rgba(255,255,255,.01));
      border:1px solid var(--cardEdge);box-shadow:var(--shadow);position:relative;transform-style:preserve-3d;transition:transform .6s cubic-bezier(.22,.61,.36,1)}
    .card.flipped{transform:rotateY(180deg)}
    .cardface{position:absolute;inset:0;padding:22px;display:flex;flex-direction:column;gap:14px;justify-content:center;align-items:center;backface-visibility:hidden}
    .card .back{transform:rotateY(180deg)}
    .panel{background:rgba(255,255,255,.04);border:1px solid rgba(255,255,255,.08);border-radius:14px;padding:14px;display:grid;gap:12px}
    textarea,input[type="text"]{width:100%;padding:10px 12px;border-radius:10px;border:1px solid rgba(255,255,255,.14);background:rgba(0,0,0,.25);color:var(--text);font-size:14px}
    .pill{display:inline-flex;align-items:center;gap:8px;background:rgba(255,255,255,.06);border:1px solid rgba(255,255,255,.12);padding:8px 10px;border-radius:999px;font-size:12px}
    .small{font-size:12px;color:var(--muted)}
    .grid2{display:grid;grid-template-columns:1fr;gap:10px}
    @media(min-width:640px){.grid2{grid-template-columns:1fr 1fr}}
    .preview{background:rgba(255,255,255,.04);border:1px dashed rgba(255,255,255,.2);padding:10px;border-radius:10px;max-height:260px;overflow:auto;font-size:13px;white-space:pre-wrap}
    .row{display:flex;gap:10px;align-items:center;flex-wrap:wrap}
    .kpi{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
  </style>
</head>
<body>
  <header>
    <h1>Karteikarten • Treuhand</h1>
    <span class="badge">Auto‑Fragen v2</span>
    <div class="spacer"></div>
    <button class="primary" id="exportDeckBtn" title="Deck exportieren">Export</button>
  </header>

  <main>
    <div class="toolbar" role="region" aria-label="Werkzeuge">
      <label for="deckSelect">Deck:</label>
      <select id="deckSelect"></select>
      <button id="newDeckBtn">Neues Deck</button>
      <button id="deleteDeckBtn">Deck löschen</button>
      <input type="file" id="importFile" accept=".json,.csv,.txt,.md,.pdf" />
      <button id="importBtn" class="primary">Importieren</button>
      <button id="shuffleBtn">Mischen</button>
      <button id="resetProgressBtn">Fortschritt zurücksetzen</button>
    </div>

    <div class="toolbar" role="region" aria-label="Auto-Fragen Optionen">
      <div class="row">
        <span class="pill">Modus:
          <select id="qaMode">
            <option value="off">Aus</option>
            <option value="lite">Einfach</option>
            <option value="aggressive" selected>Aggressiv</option>
          </select>
        </span>
        <span class="pill">Dichte:
          <select id="density">
            <option value="low">Niedrig</option>
            <option value="medium" selected>Mittel</option>
            <option value="high">Hoch</option>
          </select>
        </span>
        <span class="pill">
          Vorlagen aktiv:
          <label><input type="checkbox" id="tplDef" checked> Definition</label>
          <label><input type="checkbox" id="tplLaw" checked> Gesetz/Artikel</label>
          <label><input type="checkbox" id="tplDuty" checked> Pflichten/Rechte</label>
          <label><input type="checkbox" id="tplNum" checked> Zahlen/Quoren</label>
          <label><input type="checkbox" id="tplCompare" checked> Vergleich</label>
        </span>
      </div>
    </div>

    <div class="board">
      <section class="cardwrap" aria-live="polite">
        <div class="card" id="card">
          <div class="cardface front">
            <div class="pill">Frage</div>
            <h2 id="qText">Noch keine Karten. Importiere ein PDF/TXT oder füge eigene hinzu.</h2>
            <p class="small">Tippen/Click zum Drehen • Leertaste: drehen • 1: Nochmal • 2: Sitzts!</p>
            <div><button id="revealBtn" class="primary">Antwort zeigen</button></div>
          </div>
          <div class="cardface back">
            <div class="pill">Antwort</div>
            <p id="aText">—</p>
            <div class="grid2" style="max-width:680px;width:100%">
              <input type="text" id="selfAnswer" placeholder="Deine Antwort (optional)" />
              <button id="checkBtn">Prüfen</button>
            </div>
            <div id="checkMsg" class="small"></div>
            <div class="row" style="justify-content:center">
              <button id="againBtn">Nochmal</button>
              <button id="okBtn">Sitzts!</button>
              <button id="editCardBtn">Karte bearbeiten</button>
            </div>
          </div>
        </div>
      </section>

      <aside class="panel">
        <h3>Inhalt hinzufügen</h3>
        <div class="grid2">
          <textarea id="qInput" rows="3" placeholder="Frage…"></textarea>
          <textarea id="aInput" rows="3" placeholder="Antwort…"></textarea>
        </div>
        <div class="row">
          <button id="addCardBtn" class="primary">Karte hinzufügen</button>
          <button id="clearInputsBtn">Eingaben leeren</button>
        </div>
        <div class="small">
          Import: CSV (question,answer), TXT/MD (Frage::Antwort), PDF (Text wird extrahiert, Auto‑Fragen nutzbar), JSON (Export).
        </div>
        <div class="pill">Vorschau Auto‑Fragen <span id="qaCount">0</span></div>
        <div id="qaPreview" class="preview">—</div>
        <div class="kpi">
          <span class="pill">Karten: <b id="kpiTotal">0</b></span>
          <span class="pill">Heute fällig: <b id="kpiDue">0</b></span>
          <span class="pill">Box 1: <b id="kpiB1">0</b></span>
          <span class="pill">Box 2: <b id="kpiB2">0</b></span>
          <span class="pill">Box 3+: <b id="kpiB3">0</b></span>
        </div>
      </aside>
    </div>

    <p class="small" style="text-align:center">Hinweis: Auto‑Fragen laufen offline im Browser. Qualität hängt von PDF‑Struktur ab. Du kannst jede Karte vor dem Import anpassen.</p>
  </main>

  <script src="https://unpkg.com/pdfjs-dist@4.4.168/build/pdf.min.js"></script>
  <script>
    const LS_KEY = "treuhand_cards_v5_autogen";
    let state = loadState();
    if(!state.decks){ state.decks = {}; state.current = null; saveState(); }
    if(Object.keys(state.decks).length===0){
      state.decks["Mein erstes Deck"] = {cards:[], created: Date.now(), color:"#9b5de5"};
      state.current = "Mein erstes Deck"; saveState();
    }
    function loadState(){ try{return JSON.parse(localStorage.getItem(LS_KEY))||{};}catch(e){return {}; } }
    function saveState(){ localStorage.setItem(LS_KEY, JSON.stringify(state)); }
    function today(){ const d=new Date(); d.setHours(0,0,0,0); return d.getTime(); }
    function days(n){ return 24*3600*1000*n; }
    function uuid(){ return Math.random().toString(36).slice(2)+Date.now().toString(36); }
    function mkCard(q,a){ return { id:uuid(), q:q.trim(), a:a.trim(), box:1, next:today(), created:Date.now(), history:[] }; }
    function currentDeck(){ return state.decks[state.current]; }
    function autoColor(){ const colors=["#9b5de5","#00bbf9","#00f5d4","#f15bb5","#f8961e","#2ecc71","#ffd166","#8e9aaf"];
      const used=new Set(Object.values(state.decks).map(d=>d.color)); for(const c of colors){ if(!used.has(c)) return c; }
      return colors[Math.floor(Math.random()*colors.length)]; }
    function id(x){ return document.getElementById(x); }

    // UI refs
    const deckSelect=id('deckSelect'), importFile=id('importFile'), qaPreview=id('qaPreview'), qaCount=id('qaCount');
    const qaMode=id('qaMode'), densitySel=id('density');
    const tplDef=id('tplDef'), tplLaw=id('tplLaw'), tplDuty=id('tplDuty'), tplNum=id('tplNum'), tplCompare=id('tplCompare');

    // Deck controls
    function refreshDeckSelect(){
      deckSelect.innerHTML="";
      Object.keys(state.decks).forEach(name=>{
        const opt=document.createElement('option'); opt.value=name; opt.textContent=name;
        if(name===state.current) opt.selected=true; deckSelect.appendChild(opt);
      });
    }
    deckSelect.addEventListener('change', ()=>{ state.current=deckSelect.value; saveState(); refreshAll(); });
    id('newDeckBtn').addEventListener('click', ()=>{
      const name=prompt("Neuer Deckname:", "Deck "+(Object.keys(state.decks).length+1)); if(!name) return;
      if(state.decks[name]) return alert("Name existiert bereits.");
      state.decks[name]={cards:[], created:Date.now(), color:autoColor()}; state.current=name; saveState(); refreshAll();
    });
    id('deleteDeckBtn').addEventListener('click', ()=>{
      if(!state.current) return; if(!confirm("Deck „"+state.current+"“ wirklich löschen?")) return;
      delete state.decks[state.current]; state.current=Object.keys(state.decks)[0]||null; saveState(); refreshAll();
    });

    // Study session
    const cardEl=id('card'), qText=id('qText'), aText=id('aText'), selfAnswer=id('selfAnswer');
    let queue=[], idx=0;
    function buildQueue(){ const d=currentDeck(); if(!d) return [];
      const now=today(); const due=d.cards.filter(c=>c.next<=now);
      const later=d.cards.filter(c=>c.next>now).sort((a,b)=>a.next-b.next);
      return [...due,...later];
    }
    function startSession(){ queue=buildQueue(); idx=0; showCard(); renderKPI(); tintCard(); }
    function showCard(){
      if(queue.length===0){ qText.textContent="Noch keine Karten."; aText.textContent="—"; cardEl.classList.remove('flipped'); return; }
      const c=queue[idx]||queue[queue.length-1]; qText.textContent=c.q; aText.textContent=c.a; cardEl.classList.remove('flipped');
    }
    function tintCard(){ const d=currentDeck(); if(!d) return; cardEl.style.boxShadow="0 12px 30px rgba(0,0,0,.35), 0 0 0 2px "+(d.color||"#8e8cd8"); }
    function flip(){ cardEl.classList.toggle('flipped'); }
    id('revealBtn').addEventListener('click', flip);
    cardEl.addEventListener('click', (e)=>{ if(e.target.closest('button,input,textarea')) return; flip(); });
    id('againBtn').addEventListener('click', ()=>grade(false));
    id('okBtn').addEventListener('click', ()=>grade(true));
    id('editCardBtn').addEventListener('click', ()=>{
      const c=queue[idx]; if(!c) return; const nq=prompt("Frage bearbeiten:", c.q); if(nq==null) return;
      const na=prompt("Antwort bearbeiten:", c.a); if(na==null) return; c.q=nq; c.a=na; saveState(); showCard();
    });
    id('checkBtn').addEventListener('click', ()=>{
      const c=queue[idx]; if(!c) return; const user=(selfAnswer.value||"").toLowerCase().trim();
      const ans=c.a.toLowerCase(); const ok = ans.includes(user) || user.includes(ans);
      id('checkMsg').textContent = user? (ok?"✓ Klingt richtig":"✕ Abweichung – oben vergleichen.") : "Keine Eingabe.";
    });
    function grade(success){
      const d=currentDeck(); if(!d || queue.length===0) return; const c=queue[idx]; const now=today();
      c.box = success ? Math.min(5, c.box+1) : 1;
      const map={1:0,2:1,3:3,4:7,5:14}; c.next = now + days(map[c.box]); c.history.push({t:Date.now(), ok:success});
      saveState(); idx=Math.min(queue.length-1, idx+1); queue=buildQueue(); renderKPI(); showCard();
    }
    id('shuffleBtn').addEventListener('click', ()=>{ const d=currentDeck(); if(!d) return; d.cards.sort(()=>Math.random()-.5); saveState(); startSession(); });
    id('resetProgressBtn').addEventListener('click', ()=>{
      const d=currentDeck(); if(!d) return; if(!confirm("Fortschritt zurücksetzen?")) return;
      d.cards.forEach(c=>{ c.box=1; c.next=today(); c.history=[]; }); saveState(); startSession();
    });
    id('exportDeckBtn').addEventListener('click', ()=>{
      const d=currentDeck(); if(!d) return; const data=JSON.stringify(d,null,2);
      download(data, (state.current||"deck")+"_export.json", "application/json");
    });
    id('addCardBtn').addEventListener('click', ()=>{
      const q=id('qInput').value.trim(); const a=id('aInput').value.trim(); if(!q||!a) return alert("Bitte Frage und Antwort.");
      currentDeck().cards.push(mkCard(q,a)); saveState(); id('qInput').value=""; id('aInput').value=""; refreshAll();
    });
    id('clearInputsBtn').addEventListener('click', ()=>{ id('qInput').value=""; id('aInput').value=""; });

    // Import
    id('importBtn').addEventListener('click', async ()=>{
      const file = importFile.files && importFile.files[0]; if(!file) return alert("Bitte Datei wählen.");
      const ext=(file.name.split('.').pop()||'').toLowerCase();
      try{
        if(ext==='json'){ await importJSON(JSON.parse(await file.text()), file); }
        else if(ext==='csv'){ await importCSV(await file.text()); }
        else if(ext==='txt' || ext==='md'){ await importFromPlain(await file.text()); }
        else if(ext==='pdf'){ await importFromPDF(file); }
        else alert("Nicht unterstützte Datei.");
      }catch(e){ console.error(e); alert("Import-Fehler: "+e.message); }
      finally{ importFile.value=""; }
    });

    async function importJSON(obj, file){
      const name = suggestDeckName(file.name.replace(/\.json$/,''));
      const newDeck = confirm("Als neues Deck „"+name+"“ importieren? (Abbrechen = in aktuelles Deck)");
      if(newDeck){ state.decks[name]={cards:[], created:Date.now(), color:autoColor()}; state.current=name; }
      if(obj.cards){ obj.cards.forEach(c=> currentDeck().cards.push(mkCard(c.q||c.question, c.a||c.answer))); }
      else if(Array.isArray(obj)){ obj.forEach(c=> currentDeck().cards.push(mkCard(c.q||c.question, c.a||c.answer))); }
      else throw new Error("Unbekanntes JSON-Format");
      saveState(); refreshAll();
    }
    async function importCSV(text){
      // Tolerant: erkennt Kopfzeilen question/answer oder Frage/Antwort und ; oder , als Trenner.
      const lines = text.split(/\r?\n/).filter(l=>l.trim().length>0);
      const head = lines[0].trim();
      const sep = head.includes(';') && !head.includes(',') ? ';' : ',';
      const cols = head.split(sep).map(s=>s.trim().toLowerCase());
      let qi = cols.indexOf('question'); let ai = cols.indexOf('answer');
      if(qi<0 && ai<0){ qi = cols.indexOf('frage'); ai = cols.indexOf('antwort'); }
      if(qi<0 || ai<0) throw new Error("CSV braucht Kopfzeile question,answer (oder Frage,Antwort).");
      for(let i=1;i<lines.length;i++){
        const row = splitCSV(lines[i], sep);
        const q = (row[qi]||"").trim(); const a = (row[ai]||"").trim();
        if(q && a) currentDeck().cards.push(mkCard(q,a));
      }
      saveState(); refreshAll();
    }
    function splitCSV(line, sep){
      const out=[]; let cur=""; let inq=false;
      for(let i=0;i<line.length;i++){
        const ch=line[i];
        if(ch=='"'){ if(inq && line[i+1]=='"'){ cur+='"'; i++; } else inq=!inq; }
        else if(ch===sep && !inq){ out.push(cur); cur=""; }
        else cur+=ch;
      }
      out.push(cur); return out;
    }

    async function importFromPlain(text){
      let made = 0;
      text.split(/\r?\n/).forEach(line=>{
        const m=line.split(/::/);
        if(m.length>=2){ const q=m.shift(); const a=m.join("::"); currentDeck().cards.push(mkCard(q,a)); made++; }
      });
      if(made>0){ saveState(); refreshAll(); return; }
      const pairs = autoQA(text);
      previewPairs(pairs);
      if(pairs.length>0 && confirm("Auto‑Fragen übernehmen? ("+pairs.length+")")){
        pairs.forEach(p=> currentDeck().cards.push(mkCard(p.q, p.a)));
        saveState(); refreshAll();
      }else if(pairs.length===0){
        alert("Keine Auto‑Fragen gefunden. Versuche Modus „Aggressiv“ und Dichte „Hoch“.");
      }
    }

    async function importFromPDF(file){
      const arrayBuf = await file.arrayBuffer();
      const pdf = await pdfjsLib.getDocument({data: arrayBuf}).promise;
      let text=""; for(let p=1;p<=pdf.numPages;p++){ const page=await pdf.getPage(p); const c=await page.getTextContent();
        text += c.items.map(i=>i.str).join(" ") + "\n\n"; }
      const name = suggestDeckName(file.name.replace(/\.pdf$/i,''));
      const newDeck = confirm("PDF erkannt. Neues Deck „"+name+"“ anlegen? (Abbrechen = aktuelles Deck)");
      if(newDeck){ state.decks[name]={cards:[], created:Date.now(), color:autoColor()}; state.current=name; saveState(); refreshAll(); }
      // Erst direkte Paare
      let made=0;
      text.split(/\r?\n/).forEach(line=>{
        const m=line.split(/::/);
        if(m.length>=2){ const q=m.shift(); const a=m.join("::"); currentDeck().cards.push(mkCard(q,a)); made++; }
      });
      if(made===0){
        const pairs = autoQA(text);
        previewPairs(pairs);
        if(pairs.length>0 && confirm("Auto‑Fragen übernehmen? ("+pairs.length+")")){
          pairs.forEach(p=> currentDeck().cards.push(mkCard(p.q, p.a)));
        }
      }
      saveState(); refreshAll();
    }

    // --------- Auto-QA v2 (regelbasiert) ---------
    function autoQA(raw){
      const mode = qaMode.value;
      if(mode==='off') return [];
      const dens = densitySel.value;
      const opts = {
        wantDef: tplDef.checked, wantLaw: tplLaw.checked, wantDuty: tplDuty.checked,
        wantNum: tplNum.checked, wantCompare: tplCompare.checked,
        mode, dens
      };
      const text = normalize(raw);
      const blocks = splitBlocks(text);
      let pairs=[];
      for(const b of blocks){
        const head = detectHeading(b);
        const local = [];
        if(opts.wantDef)   local.push(...extractDefinitions(b, head));
        if(opts.wantLaw)   local.push(...extractLaw(b));
        if(opts.wantDuty)  local.push(...extractDuties(b));
        if(opts.wantNum)   local.push(...extractNumbers(b, head));
        if(opts.wantCompare) local.push(...extractComparisons(b, head));
        local.push(...extractCoreSentences(b, opts));
        pairs.push(...local);
      }
      const cap = opts.dens==='high' ? 250 : opts.dens==='medium' ? 140 : 80;
      return dedupe(pairs).slice(0, cap);
    }

    function extractDefinitions(b, head){
      const pairs=[];
      b.split(/\n/).forEach(line=>{
        const m = line.match(/^([A-ZÄÖÜa-zäöü0-9\. ,–\-\/\(\)]+?)\s*:\s+(.{12,})$/);
        if(m){
          const label = m[1].trim(); const expl = m[2].trim();
          const q = head ? `${label} – ${head}?` : `${label} – was bedeutet das?`;
          pairs.push({q, a: expl});
        }
      });
      return pairs;
    }
    function extractLaw(b){
      const out=[];
      const re = /(Art\.\s*\d+[a-zA-Z]*\s*(?:Abs\.\s*\d+\s*)?(?:Ziff\.\s*\d+\s*)?(?:[a-zA-Z]*)?\s*(?:OR|ZGB|DBG|StHG|MWSTG))/g;
      const seen=new Set();
      let m; while((m=re.exec(b))!==null){
        const tag=m[1]; if(seen.has(tag)) continue; seen.add(tag);
        const s = firstSentenceAfter(b, tag);
        if(s && s.length>=20){
          out.push({ q:`Was regelt ${tag}?`, a: s.trim() });
        }
      }
      return out;
    }
    function extractDuties(b){
      const out=[];
      const re = /(Pflichten|Rechte|Treuepflicht|Nachschusspflicht|Nebenleistungspflicht|Konkurrenzverbot|Mitwirkungsrechte)/i;
      if(re.test(b)){
        sentences(b).forEach(s=>{
          if(/(muss|müssen|dürfen|dürfen nicht|verpflichtet|unzulässig|erlaubt)/i.test(s) && s.length>=50 && s.length<=240){
            out.push({ q: makeClozeLead(s, "Was gilt?"), a: s.trim() });
          }
        });
      }
      return out;
    }
    function extractNumbers(b, head){
      const out=[];
      const nums = b.match(/(\b\d{1,3}(?:[’'` ]\d{3})*(?:\.\d+)?\s*(?:CHF|%|Prozent|Stimmen|Tage|Jahre|Monate)\b)/g) || [];
      nums.forEach(n=>{
        const s = sentenceContaining(b, n);
        if(s && s.length>=30 && s.length<=220){
          const q = head ? `${head}: Welche Zahl/Schwelle gilt?` : `Welche Zahl/Schwelle gilt?`;
          out.push({ q, a: s.trim() });
        }
      });
      return out;
    }
    function extractComparisons(b, head){
      const out=[];
      sentences(b).forEach(s=>{
        if(/(anders als|im Gegensatz zu|Unterschied|vs\.|verglichen mit|Abweichung zur AG|abweichend zur AG)/i.test(s)){
          const q = head ? `${head}: Was ist der Unterschied?` : `Was ist der Unterschied?`;
          out.push({ q, a: s.trim() });
        }
      });
      return out;
    }
    function extractCoreSentences(b, opts){
      const out=[];
      sentences(b).forEach(s=>{
        const core = /( ist| sind| bezeichnet| umfasst| gewährt| erfordert| bewirkt| bedeutet| besagt )/i.test(s);
        const len = s.length;
        const passLen = opts.mode==='aggressive' ? (len>=40 && len<=300) : (len>=60 && len<=220);
        if(core && passLen){
          out.push({ q: makeClozeLead(s, "Worum geht es?"), a: s.trim() });
        }
      });
      return out;
    }

    // Helpers
    function normalize(t){ return t.replace(/\r/g,'').replace(/[ \t]+/g,' ').replace(/\n{3,}/g,'\n\n'); }
    function splitBlocks(t){ return t.split(/\n\s*\n/).map(b=>b.trim()).filter(Boolean); }
    function sentences(b){ return b.split(/(?<=[\.\!\?])\s+/).map(s=>s.trim()).filter(Boolean); }
    function detectHeading(b){
      const m=b.match(/^(Zusammenfassung Seite \d+|[A-ZÄÖÜ][A-Za-zÄÖÜäöüß0-9 \-]{3,60})\s*(?:\n|—|-|:)/);
      return m?m[1].trim():"";
    }
    function firstSentenceAfter(text, tag){
      const idx = text.indexOf(tag); if(idx<0) return "";
      const rest = text.slice(idx);
      const s = rest.split(/(?<=[\.\!\?])\s+/)[0];
      return s;
    }
    function sentenceContaining(text, needle){
      const arr = sentences(text);
      for(const s of arr){ if(s.includes(needle)) return s; }
      return "";
    }
    function makeClozeLead(s, lead){
      const m = s.match(/^(.*?)( ist| sind| bezeichnet| umfasst| gewährt| erfordert| bedeutet| besagt)\b/i);
      if(m){ return (m[1].trim()+" – "+lead).replace(/\s+/g,' '); }
      return lead;
    }
    function dedupe(pairs){
      const seen=new Set(); const out=[];
      for(const p of pairs){
        const key=(p.q+"||"+p.a).toLowerCase();
        if(seen.has(key)) continue; seen.add(key);
        if(p.q.length>8 && p.a.length>8) out.push(p);
      }
      return out;
    }
    function suggestDeckName(base){
      let name = base.replace(/[_\-]+/g,' ').replace(/\s+/g,' ').trim(); if(!name) name="Deck "+(Object.keys(state.decks).length+1);
      let n=name, i=2; while(state.decks[n]){ n=name+" ("+i+")"; i++; } return n;
    }
    function download(data, filename, type){ const blob=new Blob([data],{type});
      const a=document.createElement('a'); a.href=URL.createObjectURL(blob); a.download=filename; document.body.appendChild(a); a.click(); a.remove();
      setTimeout(()=>URL.revokeObjectURL(a.href),1000); }

    function renderKPI(){
      const d=currentDeck(); if(!d){ setKPI(0,0,0,0,0); return; }
      const total=d.cards.length; const now=today();
      const due=d.cards.filter(c=>c.next<=now).length;
      const b1=d.cards.filter(c=>c.box===1).length;
      const b2=d.cards.filter(c=>c.box===2).length;
      const b3=d.cards.filter(c=>c.box>=3).length;
      setKPI(total,due,b1,b2,b3);
    }
    function setKPI(t,d,b1,b2,b3){
      id('kpiTotal').textContent=t; id('kpiDue').textContent=d; id('kpiB1').textContent=b1; id('kpiB2').textContent=b2; id('kpiB3').textContent=b3;
    }

    // Preview
    function previewPairs(pairs){
      if(!pairs || pairs.length===0){ qaPreview.textContent="—"; qaCount.textContent="0"; return; }
      qaPreview.textContent = pairs.slice(0,40).map(p=>`• ${p.q}\n  → ${p.a}`).join("\n\n");
      qaCount.textContent = String(pairs.length);
    }

    function refreshAll(){ refreshDeckSelect(); renderKPI(); startSession(); }
    refreshAll();

    // Keyboard
    window.addEventListener('keydown', (e)=>{
      if(e.key===' '){ e.preventDefault(); flip(); }
      else if(e.key==='ArrowRight'){ idx=Math.min(queue.length-1, idx+1); showCard(); }
      else if(e.key==='ArrowLeft'){ idx=Math.max(0, idx-1); showCard(); }
      else if(e.key==='1'){ grade(false); }
      else if(e.key==='2'){ grade(true); }
    });
  </script>
</body>
</html>
